# JAVA 기초 정리

<details>
<summary><strong>a_intro</strong> (프로그래밍 언어)</summary>

## 1. 프로그래밍 언어
- 개발자와 운영체제가 소통하기 위한 언어

### 기본 용어
- **소스코드** : 개발자와 컴퓨터가 소통할 내용을 글로 작성한 것  
- **소스파일(.java)** : 소스코드를 담은 파일  
- **컴파일** : 사람의 언어를 운영체제 언어로 변환하는 작업  
- **컴파일러** : 컴파일을 해주는 프로그램/명령어 (위→아래, 좌→우 순서로 번역)  
- **프로그램** : 소스코드로 짜여진 틀  
- **콘솔(Console)** : 개발자와 운영체제가 소통한 결과를 보여주는 창  

---

## 2. 프로그램 구조
### 일반 프로그램
프로그램 → OS(운영체제) → 하드웨어
- 이식성이 좋지 않음  
- 하드웨어 직접 접근 가능  

### JAVA 프로그램
JAVA 프로그램 → JVM → OS(운영체제) → 하드웨어
- 이식성이 좋음  
- 하드웨어 직접 접근 어려움  

---

## 3. JVM / JRE / JDK
- **JVM (Java Virtual Machine)** : 자바 프로그램 실행기  
- **JRE (Java Runtime Environment)** : JVM + 실행에 필요한 라이브러리  
- **JDK (Java Development Kit)** : JRE + 개발 도구(컴파일러, 실행 명령어 등)  

---

## 4. JDK 설치
[JDK 다운로드](https://drive.google.com/file/d/1bsLuMXWQ-yg50m4SNToucnhEBMLSg6He/view?usp=drive_link)

### 환경변수 설정
- 설치된 프로그램을 어디서든 실행할 수 있도록 경로(Path)에 등록  
- 매번 경로로 들어갈 필요 없이 명령어처럼 사용 가능  

---

## 5. IDE 설치
- **이클립스 (무료, 정부 표준)**  
  [다운로드](https://drive.google.com/file/d/18qYUbfdkXWrX0hbSnvFOuihh9MXI_k7j/view?usp=drive_link)  
- **인텔리제이 (유료, 다양한 기능)**  

---

## 6. 기본 구조
```
프로젝트
└─ 패키지 (소문자)
  └─ 클래스 (대문자)
    └─ 메소드 (이름 + ())
      └─ 소스코드
```
</details> 

<details>
<summary><strong>b_print</strong> (메소드)</summary>
# 출력 메소드

## 1. 메소드 종류
1. **print()** : 마지막에 자동으로 줄바꿈되지 않고, 아래 문장과 이어서 출력된다.  
2. **println()** : 마지막에 자동으로 줄바꿈된다.  
3. **printf()** : 서식 문자를 사용하여 출력할 수 있으며, 자동으로 줄바꿈되지 않는다.  

---

## 2. 출력 메소드를 사용하는 이유
- 오류를 구체화하기 위해 개발자가 사용하는 도구이다.

### 예시 1 (출력문이 없는 경우)
java
A 코드
B 코드
C 코드
D 코드

오류 발생 시 어떤 라인에서 발생했는지 알 수 없다.

### 예시 2 (출력문이 없는 경우)
A 코드
System.out.println("A");
B 코드
System.out.println("B");
C 코드
System.out.println("C");
D 코드
System.out.println("D");

"C"까지 콘솔에 출력되었다면, 위에서 아래로 번역되기 때문에
D 코드 부분에서 문제가 발생한 것으로 판단할 수 있다.
</details> 


<details>
<summary><strong>c_variable</strong> (변수)</summary>

## 변수
- 변수는 저장공간이다.

x = 10
이름 연산자 대입 값(상수)

---

## 자료형 (type)
- 자료형은 저장공간의 종류이다.

| 자료형 | type   | byte | 값 |
|--------|--------|------|----|
| 정수형 | byte   | 1    | 1, 4, -120, 100 ... |
|        | short  | 2    | 123, 9, 150, -55 ... |
|        | int    | 4    | -2147483648 ~ 2147483647 |
|        | long   | 8    | 30L, 8L, -154616978L ... |
| 실수형 | float  | 4    | 3.12F, 2.59F, -123.5145F, 2.0F |
|        | double | 8    | 3.12, 2.59, -123.5145, 2.0 |
| 문자형 | char   | 2    | 'a', 'b', '3' ... |
| 문자열 | String | ???  | "ABC", "0.0", "123.3213", "A", "안녕" ... |

---

## 변수의 선언
- 자료형 변수명 = 초기값; // 초기화
- 자료형 변수명;

> 예시:
> ```java
> int x = 10;
> // x라는 이름의 저장공간이 int형으로 할당되고 그 안에 10이 들어간다.
> ```

---

## 주소 
int x = 10;
- x라는 이름의 저장공간이 int형으로 RAM에 할당되면, 고유한 주소값이 부여된다.
- 실행 및 종료에 따라 주소가 이동할 수는 있으나 중복은 없다.

---

## 변수의 사용
변수는 사용한 부분 전체를 반드시 값으로 본다.
> 예시:
> ```java
> int data = 10;   // 저장공간
> data = 20;       // 저장공간
> data + 9;        // 값
> data = data + 2; // 저장공간, 값
> ```

---

## 변수 선언시 주의사항
1. 같은 이름의 변수로 선언할 수 없다.
2. 초기화를 해준다.
		정수: 0
		실수: 0.0
		문자: ' '
		문자열: "", null
3. 되도록 선언부에 한꺼번에 선언한다(영역 상단).

---

## 변수명 주의사항
1. 문자로 시작해야 한다.
2. 특수문자를 사용할 수 없다. 단, _는 허용한다.
3. 소문자로 시작한다.
4. 공백을 사용할 수 없다.
	- good boy
	- good_boy: 언더바 표기법
	- goodBoy: 카멜 표기법
5. 되도록 한글을 사용하지 않는다.
6. 명사로 사용한다.
7. 뜻이 있는 단어를 사용한다.
	- a, b, c, d, e, f, ... (X)
	- number, num, data, age, name, ... (O)

---

## 변수를 사용하는 이유
1. 반복되는 값을 쉽게 관리하기 위해서
2. 의미 없는 값을 하나의 정보로 만들기 위해서(자료구조)
</details> 


<details>
<summary><strong>d_casting</strong> (형변환)</summary>

## 형변환

### 자동 형변환
- 정수 + 정수 = 정수  
- 정수 + 실수 = 실수  
- 정수 + 문자 = 정수  

### 강제 형변환 (Casting)
> 예시:
> ```java
> (자료형)값
> (double)3 == 3.0
> ```

---

## 문자열 형변환

### 1. 다른 자료형을 문자열로
- 문자열과 다른 일반 자료형을 연결하면 결과는 문자열이 된다.

### 2. 문자열을 다른 자료형으로
- 일반 자료형은 일반 자료형끼리만 형변환이 가능하다.  
- 문자열 타입은 클래스 타입이므로, 일반 자료형의 클래스 타입의 도움을 받아야 한다.  

> ```java
> Integer.parseInt("123");     // 문자열 → 정수
> Double.parseDouble("3.14");  // 문자열 → 실수
> ```

</details>

<details>
<summary><strong>e_constant</strong> (상수)</summary>

## 상수
- 항상 그대로인 수  
- 값은 변경할 수 없다  

> 예시:
> ```java
> final 자료형 상수명 = 값;
> ```

---

## 상수를 사용하는 이유
- 값에 의미부여를 하기 위해서
</details>


<details>
<summary><strong>f_input</strong> (입력)</summary>

## 입력
- 커서가 깜빡이고 있는 상태를 입력 상태라고 한다.  
- 입력하기 전에 출력을 통해 어떤 값을 입력해야 할지 사용자에게 알려주어야 한다.  

---

## 입력 클래스
> ```java
> Scanner sc = new Scanner(System.in);
> ------- --   -----------------------
> 자료형 변수명	    값

## 입력 메소드
### next(): 사용자가 입력한 문자열 값
 - 사용자가 입력한 값 중 공백 또는 줄바꿈 문자(엔터)를 구분점으로 각 문자열을 분리한다.
 - 첫 번째 문자열은 첫 번째 next()에 담기고 두 번째 문자열은 두 번째 next()에 담긴다.

### nextLine(): 사용자가 입력한 문자열 값
 - 공백 문자도 값으로 취급하기 때문에 그대로 입력받는다.
</details>


<details>
<summary><strong>g_operator</strong> (연산자)</summary>

## 연산자
- 기능이 있는 특수문자  

---

## 연산자의 우선순위
하나의 식에 여러 종류의 연산자가 사용될 경우, 어떤 순서로 연산되는지를 알아보자.

1. 최우선 연산자  
2. 단항 연산자  
3. 산술 연산자  
4. 쉬프트 연산자  
5. 관계 연산자  
6. 논리 연산자  
7. 삼항 연산자  
8. 대입 연산자  

---

## 결합성
- 하나의 식에 동일한 연산자가 여러 개 사용되면 알맞은 방향으로 결합되어 연산되는 성질  

---

## 논리형 (boolean)
- 참: `true`  
- 거짓: `false`  

> ```java
> boolean check = true;
> boolean check = 10 > 11;
> // 초기값은 false이다.


## 조건식
- 결과가 참 또는 거짓, 둘 중 하나가 나오는 식  
- 항상 조건식은 값으로 봐야 한다  

### 관계 연산자
- `==` : 같다  
- `!=` : 같지 않다  
- `>`, `<` : 초과, 미만  
- `>=`, `<=` : 이상, 이하  

### 논리 연산자
- `&&` (AND), `A && B` → 두 조건식 모두 참이면 참  
- `||` (OR), `A || B` → 둘 중 하나라도 참이면 참  

### 단항 연산자
- `!` (NOT), `!A` → 참을 거짓으로, 거짓을 참으로 변경  

### 삼항 연산자
- `? :` → 조건식 ? 참 : 거짓  
- 조건식이 참이면 참, 거짓이면 거짓

  > 예시:
  > int result = (10 > 11 ? 10 : 11) + 3;

---

## 대입 연산자 (복합 대입 연산자, 누적 연산자)
- `+=`, `-=`, `*=`, `/=`, `...`

 > ```java
 > int money = 10000;
 > // money = money - 1000
 > money -= 1000;
 > System.out.println(money);
 > ```

 > ```java
 > int data = 10;
 > // data = data + 1;
 > // data += 1;
 > data++;
 > System.out.println(data);
 > ```

---

## 증감 연산자
- `++`, `--`

### 전위형: 해당 라인부터 바로 적용된다.
- `++data`, `--data`

### 후위형: 다음 라인부터 적용된다.
- `data++`, `data--`
</details>


<details>
<summary><strong>h_control</strong> (제어문)</summary>

## 제어문
- 컴파일러의 흐름을 제어할 수 있는 문법  

---

## 조건문

### if문
> ```java
> if (조건식) {
>     실행할 문장;
> }
> // (1)  위의 조건식 결과와 상관 없이 무조건 검사
> if(조건식){
>     실행할 문장;
> }
> // (2) 위의 조건식이 false여야 검사, true라면 검사하지 않는다.
> else if(조건식){
>     실행할 문장;
> }
>	else if(조건식){
>     실행할 문장;
> }
>	...
>	else {
>     실행할 문장;
> }
> ```

### switch문
> ```java
> switch (값) {
>    case 값1:
>        실행할 문장;
>        break;
>    case 값2:
>        실행할 문장;
>        break;
>    ...
>    default:
>        실행할 문장;
>        break;
> }
> ```

※ 삼항 연산자, if문, switch문의 비교
  - 삼항 연산자: 조건식을 1개만 사용할 때
  - if문: 조건식에 비교(>, <, >=, <=) 연산자를 사용하거나, 여러 개의 조건식을 논리 연산자로 연결할 때
  - switch문: 하나의 변수에 여러 경우의 값이 담길 수 있고, 각 값이 같은지 비교할 때

## 반복문

### for문
> ```java
> int i = 0;    i < 10;   i ++
> for(초기식; 조건식; 증감식) {
>	    실행할 문장;
> }
> ```

  1. 초기식
  -------------------
  2. 조건식(true)
  3. 실행할 문장
  4. 증감식

  5. 조건식(true)
  6. 실행할 문장
  7. 증감식

  8. 조건식(false)
  9. 종료


### while문
> ```java
> while(조건식){
>   실행할 문장;
> }
> ```

### do ~ while문
> ```java
> do {
>   실행할 문장;
> } while(조건식);
> ```

	※ for문, while문, do~while문
		- for문: 몇 번 반복할지 알 때
		- while문: 몇 번 반복할지 모를 때
		- do~while문: 무조건 처음 한 번은 실행해야 할 때

## 기타 제어문

### break
- 즉시 해당 중괄호 영역을 탈출한다.  
- if문 안에서 사용 시, **if문을 탈출하는 것이 아니라 감싸고 있는 중괄호 영역**을 탈출한다.  

### continue
- 즉시 다음 반복으로 넘어간다.  
- 아래의 코드를 실행하지 않기 위해서 사용한다.  
</details>


<details>
<summary><strong>i_array</strong> (배열)</summary>

## 배열: 저장공간의 나열
1. 변수를 여러 개 선언하면 이름도 여러 개 생겨 관리가 불편하다. **n칸 배열**을 한 번 선언하면 저장공간도 n개, 이름은 한 개라서 관리가 편하다.  
2. 규칙성이 없는 값에 **규칙성을 부여**하기 위해 사용한다.

---

## 배열의 선언
> ```java
> 자료형[] 배열명 = {값1, 값2, ...};  // 어떤 값을 넣을지 알 때
> 자료형[] 배열명 = new 자료형[칸수]; // 값은 모르지만 칸수는 알 때
> 자료형[] 배열명 = null;            // 값/칸수 모두 모를 때
> ```

- new : Heap 메모리에 할당, 초기값 자동 초기화
- null : 주소의 초기값, 어떤 주소를 넣을지 모를 때 사용
- 자바에서 배열은 항상 Heap(동적 메모리) 에 할당된다.


## 배열의 구조
> ```java
> int[] arData = {3, 5, 1, 2, 8};
> ```

- arData라는 이름의 저장공간 한 개가 만들어지며, 여기에는 한 개의 값만 담을 수 있다.
- 5개의 값을 담기 위해서는 5칸이 필요하며, 이는 Heap 메모리에 할당된다.
- 5칸의 저장공간 중, 첫 번째 저장공간의 주소값이 arData 저장공간으로 들어가며, 다음 주소에 접근하기 위해서는 + n을 한다.
- 예를 들어 arData + 2는 1이라는 값이 담긴 주소값이 되며,
  - *(arData + 2)는 해당 주소에 가서 읽어온 1이라는 값이 된다.
  - JAVA에서는 직접 주소에 접근하는 연산자가 없기 때문에 위와 같은 식을 []로 치환하여 사용한다.
  - 즉, arData[2]는 1이란 값이 된다. 방 번호는 index라고 부르며, 배열은 시작주소를 가지고 있기 때문에 인덱스 번호는 항상 0부터 시작된다.

## length
- 배열을 선언하면 length라는 상수가 선언되고, 해당 배열의 길이가 담긴다.
- 배열명.length로 사용하게 된다.

## 배열의 사용
> ```java
> int[] arData = new int[5];            // 저장공간
> arData[0] = 120;                      // 저장공간
> arData[0] + 9;                        // 값
> System.out.println(arData);           // 주소값(참조 표시)
> arData[2] = arData[0] + arData[1];    // 저장공간, 값, 값
> System.out.println(arData[5]);        // 오류 (IndexOutOfBounds)
> ```

## 2차원 배열
- 배열 안에 배열
- 1차원 배열을 여러 개 선언하면, 관리하기 어렵다.
- 2차원 배열 n행 m열을 한 번만 선언하자!
- ※ 2차원 배열부터는 메모리 낭비가 심하므로 선호하지 않는다.

### 2차원 배열 선언
> ```java
> 자료형[][] 배열명 = {{값1, 값2, ...}, {값3, 값4, ...}, ...};
>자료형[][] 배열명 = new 자료형[행][열];
> 자료형[][] 배열명 = null;
>
> int[][] arrData = new int[2][3];
> □		arrData		arrData.length: 행의 길이 
> □□		arrData[행]	arrData[행].length: 열의 길이
> □□□ □□□	arrData[행][열]
> ```
</details>


<details>
<summary><strong>j_method</strong> (메소드)</summary>

## 메소드
- **이름 뒤에 소괄호**가 오면 메소드  
- 단, **키워드 뒤에 소괄호는 메소드가 아님** → 저장공간  

---

## 메소드의 개념
> ```java
> f       (x)       =   2x + 1
> 메소드 매개(=연결)     리턴값
> 이름 변수
> ```

- `()` : 소괄호  
- `{}` : 중괄호  
- `[]` : 대괄호

---

## 메소드 선언
> ```java
> (1)리턴타입 (2)메소드명(자료형 (3)매개변수명, ...) {
>    (4)실행할 문장
>    (5)return 리턴값;
> }
> ```

## 설명

### 리턴타입
- 리턴값이 있다면 리턴값의 자료형 작성  
- 리턴값이 없다면 `void` 작성  

### 메소드명
- 동사로 작성 (예: `usePencil()`)  

### 매개변수
- 외부에서 전달받은 값이 있다면, 자료형과 순서에 맞게 선언  
- 생략하면 외부에서 값을 전달받을 수 없음  

### 실행할 문장
- 생략 가능  
- 메소드의 기능을 구현하는 로직 작성  

### return 리턴값
- 생략 가능  
- 리턴값이 있다면, 사용한 부분 전체가 리턴값으로 대체됨


---

## 메소드 선언 순서  
문제) 두 정수의 덧셈 메소드 선언  

### 1. 메소드 이름을 생각한다
> ```java
> add() {}
> ```

### 2. 매개변수를 생각한다.
> ```java
> add(int number1, int number2){}
> ```

### 3. 실행할 문장을 작성한다.
> ```java
> add(int number1, int number2){
>			int result = number1 +number2
> }
> ```

### 4. 리턴값을 작성한다.
> ```java
> add(int number1, int number2){
>			int result = number1 +number2
>			result result;
>	}
> ```

### 5. 리턴타입을 결정한다.
> ```java
> int add(int number1, int number2){
>			int result = number1 +number2
>			result result;
>	}
> ```

---

## 메소드 주의사항
1. 메소드를 선언할 때는 **`{}`가 있으며**, 반드시 메소드 **밖에서** 선언한다.  
2. 메소드를 사용할 때는 **`{}`가 없으며**, 반드시 메소드 **안에서** 사용한다.  

---

## 메소드를 사용하는 이유
1. **재사용** (특정성을 부여해서는 안 된다)  
2. **소스코드 간결화**  

---

## 다형성 (Polymorphism)

### 1. 오버로딩 (Overloading)
- 매개변수의 개수 또는 자료형이 다르면 동일한 이름의 메소드로 선언할 수 있다.  

### 2. 오버라이딩 (Overriding, 무시하기·재정의)
- 부모 클래스에서 선언한 메소드를 자식 클래스에서 재정의할 수 있다.  
- 같은 이름의 메소드를 자식에서 선언하면, **자식 객체로 접근 시 자식(this)에서 재정의된 메소드가 사용된다.**  
- 만약 재정의된 메소드 안에서 부모의 기능을 그대로 사용하고 싶다면, **`super`** 키워드로 부모 메소드에 접근할 수 있다.  
</details>


<details>
<summary><strong>k_class</strong> (클래스)</summary>

## 클래스 (반)
- 공통 요소를 한 번만 선언해 놓고 가져다 사용하도록 설계한다.

1. 타입이다.  
     - 클래스 안에 선언된 변수와 메소드를 사용하려면 해당 클래스 타입으로 변수를 선언해야 한다.  

2. 주어이다.
     > ```java
     > Monkey.eat("바나나");
     > // 원숭이가 먹는다 바나나를.
     > ```

		-항상 클래스로 시작하기 때문에 클래스는 앞글자를 대문자로 작성해야 한다.


## 클래스 선언
> ```java
> class 클래스명 {
>    필드(변수, 메소드)
> }
> ```


## 클래스 필드 사용
1. 객체화(instance) : 객체(instance variable)을 만드는 작업, 추상적인 개념을 구체화시키는 작업.
  > ```java
  > 클래스명 객체명 = new 클래스명()
  > ```
    ※ .(마침표): 하위 연산자, 멤버변수 접근 연산자, 닷 연산자, 점 연산자
	    주소값 뒤에서만 사용이 가능하며, 해당 주소를 참조하는 명령이다.

2.static: 모든 객체가 공유해야하는 필드일 경우에 사용한다.
  - 클래스 하나 당 한 개만 생기기 때문에 객체로 접근하지 않고 클래스로 접근한다.


## 생성자
- 클래스 이름 뒤에 소괄호가 있는 형태, 메소드와 기능이 똑같지만 메소드라고 부르지 않는다.
- 생성자는 리턴이라는 기능이 존재하지 않기 때문이다.

1. 해당 클래스의 필드를 메모리에 할당한 후 부여된 주소값을 가져온다.
2. 초기화


## 기본 생성자
- 매개변수가 없는 생성자이며, 클래스 선언시 자동으로 선언된다.
- 사용자가 직접 생성자를 선언하게 되면 기본 생성자는 없어진다.


## this
- 필드에 접근한 객체가 누군지 알아야 해당 필드에 접근할 수 있다.
- 이 때 접근한 객체가 가지고 있는 필드의 주소값이 this라는 변수에 자동으로 담긴다.

## 변수의 종류
- 전역 변수
  - 클래스의 필드로서, 메소드 밖에 선언하며 클래스 내에 모든 메소드에서 접근 가능하다.
  - 생성자를 통해 메모리에 할당되고, 객체마다 별도로 존재한다.
  - 즉, 전역변수는 클래스의 우선요소로 선언된다.

- 지역 변수
  - 메소드 내부 또는 {}내부에서 선언되는 변수로서,
  - 선언된 영역 내에서만 사용할 수 있다. 해당 영역이 종료되면 사라진다.
  - 초기화를 하지 않으면 사용할 수 없기 때문에 반드시 직접 초기화해준다.

- 정적 변수(static 변수)
  - 클래스 변수라고도 하며, static 키워드를 사용해준다.
  - 프로그램 실행 시 가장 먼저 메모리에 할당되고, 단 한 번만 할당된다.
  - 모든 객체가 공유하기 때문에 객체 생성 없이 클래스로 접근 할 수 있다.
</details>


<details>
<summary><strong>l_inheritance</strong> (상속 & 접근 제어자)</summary>

## 상속(inheritance) - **반드시 기본 생성자를 만들자!**
1. 기존에 선언된 클래의 필드를 새롭게 만들 클래스의 필드로 사용하고자 할 때
2. 여러 클래스 선언 시 필드가 겹치면 부모 클래스를 먼저 선언하고 공통 필드를 묶어서 각 자식 클래스들에게 상속해준다.
  - **A** : 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
	- **B** : 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스

---

## super() : 부모 생성자
- 자식 클래스 타입의 객체는 부모 필드에 접근 할 수 있다.
- 하지만 자식 생성자만 호출하기 때문에, 자식 필드만 메모리에 할당된다.
- 그렇기 때문에 B타입의 객체로 A필드(부모필드)에 접근할 수 없어야 정상이다.
- 사실 자식 생성자에서 항상 부모 생성자를 호출하기 때문에 자식 생성자 호출시 부모와 자식 필드 모두 메모리에 할당된다.
- 부모 생성자를 호출하는 방법: **`super()`**

### 특징
- `super()`는 작성하지 않아도 컴파일러가 자동으로 추가해준다.  
- 반드시 **코드의 맨 첫 줄**에서 호출해야 한다.  

---

## 접근 권한 제어자 (Access Modifiers)
1. **default** : 다른 패키지에서 접근 불가  
2. **public** : 모든 곳(프로젝트 내)에서 접근 가능  
   - 클래스 앞에 붙이면 해당 파일의 **메인 클래스**를 의미한다. 
3. **protected** : 다른 패키지에서 접근 불가, 단 자식 클래스는 접근 가능  
4. **private** : 다른 클래스에서 접근 불가

※ private을 이해해보자
- 주로 메소드로 접근하기 위해 사용된다.
- 왜냐하면, 화면(외부)에서 해당 필드를 접근하는 방법은 오로지 메소드 뿐이기 때문이다.
- private 접근자를 붙이고 외부에서 접근할 수 있도록 public 메소드를 만들어 놓는 것이 모델링 컨벤션이다.
- 이 때 public 메소드는 2가지이고, 각각 getter, setter라고 부른다.
- 이제부터는 정보를 담아놓을 클래스를 선언할 때, 각 변수 앞에 private을 붙여주고
- 이를 접근할 수 있도록 public 접근자로 getter, setter를 선언하기로 약속한다.

> 예시:
> ```java
> public class Member {
>    private String name;
>
>    // getter
>    public String getName() {
>        return name;
>    }
>
>    // setter
>    public void setName(String name) {
>        this.name = name;
>    }
> }
> ```


















